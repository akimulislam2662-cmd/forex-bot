import logging
import asyncio
import os
import threading
from flask import Flask
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes

# --- Render Port Fix (Flask Server) ---
# ‡¶è‡¶ü‡¶ø Render-‡¶è‡¶∞ "Port scan timeout" ‡¶è‡¶∞‡¶∞ ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶¨‡ßá
app = Flask('')
@app.route('/')
def home(): return "Bot is running and forwarding links to Admin!"

def run_flask():
    port = int(os.environ.get("PORT", 8080))
    app.run(host='0.0.0.0', port=port)

def keep_alive():
    threading.Thread(target=run_flask).start()
# ---------------------------------------

# ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶§‡¶•‡ßç‡¶Ø
TOKEN = "8252198993:AAEjST5jy6aOH3nJMaDFvQuHTZ7osvA48CQ"
ADMIN_ID = 6910394408

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‡¶π‡ßç‡¶Ø‡¶æ‡¶≤‡ßã! ‡¶Ü‡¶Æ‡¶æ‡¶ï‡ßá ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï ‡¶¶‡¶ø‡¶®‡•§")

async def handle_link(update: Update, context: ContextTypes.DEFAULT_TYPE):
    url = update.message.text
    if "http" not in url:
        await update.message.reply_text("‡¶¶‡ßü‡¶æ ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶†‡¶ø‡¶ï ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï ‡¶¶‡¶ø‡¶®‡•§")
        return

    context.user_data['url'] = url
    keyboard = [[InlineKeyboardButton("üé¨ Video", callback_data='vid'),
                 InlineKeyboardButton("üéµ Audio", callback_data='aud')]]
    
    await update.message.reply_text("‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶®? ‡¶®‡¶ø‡¶ö‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡¶≤‡ßá ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶ü‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡¶ï‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡¶¨‡ßá:", 
                                   reply_markup=InlineKeyboardMarkup(keyboard))

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    url = context.user_data.get('url')
    user_name = query.from_user.full_name
    choice = "‡¶≠‡¶ø‡¶°‡¶ø‡¶ì (MP4)" if query.data == 'vid' else "‡¶Ö‡¶°‡¶ø‡¶ì (MP3)"

    # ‡ßß. ‡¶á‡¶â‡¶ú‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶•‡ßá‡¶ï‡ßá ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶ü‡¶ø ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ
    try:
        await query.message.delete()
        await context.bot.send_message(chat_id=query.message.chat_id, 
                                     text="‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß‡¶ü‡¶ø ‡¶∞‡¶ø‡¶∏‡¶ø‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶ü‡¶ø ‡¶è‡¶ñ‡¶æ‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶∞‡¶ø‡¶Æ‡ßÅ‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")
    except Exception as e:
        logging.error(f"Delete Error: {e}")

    # ‡ß®. ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶ü‡¶ø ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡ßá‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã
    admin_report = f"üöÄ ‡¶®‡¶§‡ßÅ‡¶® ‡¶∞‡¶ø‡¶ï‡ßã‡ßü‡ßá‡¶∏‡ßç‡¶ü!\nüë§ ‡¶á‡¶â‡¶ú‡¶æ‡¶∞: {user_name}\nüìÇ ‡¶ü‡¶æ‡¶á‡¶™: {choice}\nüîó ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï: {url}"
    await context.bot.send_message(chat_id=ADMIN_ID, text=admin_report)

async def main():
    # Flask ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶§‡ßá Render-‡¶è ‡¶¨‡¶ü ‡¶≤‡¶æ‡¶á‡¶≠ ‡¶•‡¶æ‡¶ï‡ßá
    keep_alive() 
    
    application = Application.builder().token(TOKEN).concurrent_updates(True).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_link))
    application.add_handler(CallbackQueryHandler(button_callback))
    
    print("‡¶¨‡¶ü ‡¶∏‡¶ö‡¶≤ ‡¶Ü‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï ‡¶´‡¶∞‡¶ì‡ßü‡¶æ‡¶∞‡ßç‡¶°‡¶ø‡¶Ç ‡¶Æ‡ßã‡¶° ‡¶ö‡¶æ‡¶≤‡ßÅ...")
    await application.run_polling()

if __name__ == '__main__':
    asyncio.run(main())
    
